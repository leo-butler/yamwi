<!doctype html>
<html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <link rel="stylesheet" media="all" href="help.css">
  <title>Sistema de axuda de Yamwi en liña</title>
</head>

<body>


<h1>Sistema de axuda de Yamwi en liña</h1>



<h2>Introdución</h2>

<p>
Esta páxina <i>web</i> permite facer todo tipo de cálculos matemáticos e gráficos en liña.
</p>

<p>
Para facer un cálculo calquera tan só é necesario escribir no cadro o código correspondente e a continuación premer no botón que está debaixo.
</p>

<p>
Os exemplos que se inclúen nesta páxina pódense copiar e pegar (CTRL-C e CTRL-V) na área de edición antes de premer no botón. O usuario pode facer os cambios que queira nesta área.
</p>

<p>
A axuda desta páxina é moi precaria e básica. Para afondar máis:
</p>

<ul>
<li>Aula virtual: <a href="http://centros.edu.xunta.es/iespuntacandieira/moodle/course/view.php?id=14">Cálculo Simbólico e Numérico con Maxima</a>. (En galego.)</li>
<li>Referencia oficial: <a href="http://maxima.sourceforge.net/docs/manual/es/maxima.html" target="_blank">Manual de Maxima</a>. (En castelán.)</li>
<li>Tutorial: <a href="http://www.telefonica.net/web2/biomates/maxima/max.pdf">Primeros pasos en Maxima</a>. (En castelán.)</li>
<li>Dende a páxina oficial: <a href="http://maxima.sourceforge.net/es/documentation.html" target="_blank">Máis titoriais</a>. (Varias linguas.)</li>
</ul>

<p>
A información que imos obter ten aspecto de conversación. As nosas peticións levan sempre a etiqueta <b>%i</b> seguida dun número (<b>i</b> de <i>input</i>) e os resultados levan a etiqueta <b>%o</b> seguida do correspondente número de orde (<b>o</b> de <i>output</i>).
</p>





<hr>
<h2>Contido</h2>

<ul>
<li><a href="#numeros">Números</a>
  <ul>
  <li><a href="#enteiros">Enteiros</a></li>
  <li><a href="#racionais">Racionais</a></li>
  <li><a href="#complexos">Complexos</a></li>
  </ul>
</li>
<li><a href="#alxebra">Álxebra</a>
  <ul>
  <li><a href="#polinomios">Polinomios</a></li>
  <li><a href="#ecuacions">Ecuacións</a></li>
  <li><a href="#vectores">Vectores</a></li>
  <li><a href="#matrices">Matrices</a></li>
  </ul>
</li>
<li><a href="#calculo">Cálculo</a>
  <ul>
  <li><a href="#limites">Límites</a></li>
  <li><a href="#derivadas">Derivadas</a></li>
  <li><a href="#integrais">Integrais</a></li>
  <li><a href="#ecdiferenciais">Ecuacións diferenciais</a></li>
  </ul>
</li>
<li><a href="#graficos">Gráficos</a></li>
<li><a href="#estatistica">Estatística</a></li>
</ul>












<hr>
<h2 id="numeros">Números</h2>

<h3 id="enteiros">Enteiros</h3>

<p>Pódense utilizar enteiros tan grandes como sexa necesario. Aquí calculamos o factorial de 100,</p>

<pre>
100! ;
</pre>

<p>Coma en calquera outra linguaxe de programación, podemos sumar (<b>+</b>), restar (<b>-</b>), multiplicar (<b>*</b>), dividir (<b>/</b>), calcular potencias (<b>^</b>) y raíces cadradas (<b>sqrt</b>).</p>

<pre>
3^4 * (5-91+(-24)) + 75 / sqrt(25) ;
</pre>

<p>Vexamos a lista dos divisores dun enteiro dado e a súa factorización en números primos,</p>

<pre>
/* primeiro gardamos o numero na variable a */
a: 169996284 $
divisors(a) ;
factor(a) ;
</pre>

<p>Preguntamos a Maxima se 1502933 é un número primo.</p>

<pre>
primep(1502933);
</pre>

<p>Facemos uso de <b>gcd</b> para calcular o <i>máximo común divisor</i> de dous números e <b>lcm</b> para o <i>mínimo común múltiplo</i> dun conxunto arbitrario de enteiros, pero tendo en conta que para usar <b>lcm</b> temos que cargar primeiro a libraría <b>functs</b>.</p>

<pre>
gcd(16479936, 43375500000); 

load("functs")$
lcm(16479936, 43375500000, 111375);
</pre>

<p>A función <b>divide</b> devolve unha lista con dous elementos, o cociente e o resto (módulo) dunha división enteira.</p>

<pre>
divide(34, 5);
</pre>








<h3 id="racionais">Racionais</h3>

<p>
Maxima sempre evita traballar con cantidades aproximadas. Co seguinte código operamos con racionais. Cada instrucción debe rematar cun punto e coma (<b>;</b>).
</p>

<pre>
1 + 5 * (5 - 7/9)^4 ;
</pre>

<p>
Se queremos a aproximación decimal dun resultado podemos proceder como segue: primeiro gardamos (cos dous puntos <b>:</b>) nunha variable (neste caso <b>x</b>) o valor da expresión exacta e despois executamos a función <b>float</b> para que a transforme en decimal.
</p>

<pre>
x : 1 + 5 * (5 - 7/9)^4 ;
float(x);
</pre>

<p>
O mesmo resultado se pode acadar cunha soa instrucción.
</p>

<pre>
float (1 + 5 * (5 - 7/9)^4) ;
</pre>

<p>
Outro exemplo onde se ve o uso de variables. O que se escribe entre os símbolos <b>/*</b> e <b>*/</b> son comentarios para os humanos, sendo ignorados pola máquina, polo que este exemplo é autoexplicativo.
</p>

<pre>
/* Gardamos un valor na variable 'a' */
a : 8 / 24;

/* Gardamos outro valor na variable 'b' */
b: 1/5 ;

/* O cadrado da suma de 'a' e 'b' */
(a + b)^2;
</pre>

<p>
A función <b>float</b> devolve un número limitado de decimais. Vexamos como pedir o número &pi; con cinco mil decimais. Para iso debemos indicarlle á variable global <b>fpprec</b> a precisión desexada e despois facer unha chamada á función <b>bfloat</b>. Convén lembrar que &pi; se representa en Maxima por <b>%pi</b>. Tamén calculamos a raíz cadrada de 2 con 5000 cifras decimais.
</p>

<pre>
fpprec : 5000;
bfloat(%pi);

/* Tamen queremos a raiz cuadrada de dous */
bfloat( sqrt(2) );
</pre>










<h3 id="complexos">Complexos</h3>

<p>A unidade imaxinaria represéntase por <b>%i</b>. Con este símbolo, podemos escribir cualquera número complexo e realizar algunhas operacións con eles.</p>

<pre>
z1: 3 + 5*%i;
z2: 2/3 - %i;

z1 + z2;
z1 - z2;
</pre>

<p>Ás veces, Maxima devolve expresións complexas con parénteses. Se queremos simplificalas, podemos chamar á función <b>expand</b>.</p>

<pre>
z1: 3 + 5*%i $
z2: 2/3 - %i $

3*z1 - 7*z2;
expand(3*z1 - 7*z2);

z1 * z2;
expand(z1 * z2);
</pre>

<p>Podemos transformar números complexos en forma binomial á súa forma polar e ó revés.</p>

<pre>
z: 3 + 5*%i ;
p: polarform(z);
b: rectform(p);
</pre>

<p>Dividamos dous números complexos e obteñamos o resultado en forma binomial,</p>

<pre>
d: (3 + 5*%i) / (7/8 - 1/4*%i) ;
rectform(d);
</pre>

<p>Dado un número complexo, podemos obter as súas partes real e imaxinaria, así coma o seu módulo e ángulo.</p>

<pre>
z: 7/8 - 1/4*%i;
realpart(z);
imagpart(z);
cabs(z);
carg(z);
</pre>









<hr>
<h2 id="alxebra">Álxebra</h2>





<h3 id="polinomios">Polinomios</h3>

<p>
Da mesma maneira que podemos operar con números podemos facelo con variables. Fíxate como se reducen as expresións alxébricas.
</p>

<pre>
1 + x + 5 * y - 2/3 * x + y + 2 ;

(5*x^2 * u * r) / (u^2 * t) ;
</pre>

<p>
Expandimos produtos.
</p>

<pre>
expand( (x+1)^2 * (x+5) * (x-a) ) ;
</pre>


<p>
Factorizamos polinomios.
</p>

<pre>
factor(u^6 - 14*u^5 - 23*u^4 + 808*u^3 - 320*u^2 - 12800*u) ;
</pre>

<p>
Se queremos calcular o valor numérico dunha expresión alxébrica, faremos uso da función <b>subst</b> tal como se indica a continuación, onde gardamos na variable <b>f</b> a fórmula para a forza de atracción gravitatoria e a calculamos para diferentes masas e distancias. O uso dos corchetes (<b>[</b> e <b>]</b>) en Maxima é moi común, xa que con eles podemos construir listas e calesqueira outras estruturas de datos.
</p>

<pre>
f : 6.67 * 10^-11 * m1 * m2 / r^2 ;

subst([m1 = 4, m2 = 5, r = 7], f) ;
subst([m1 = mass, m2 = mass], f) ;
</pre>








<h3 id="ecuacions">Ecuacións</h3>

<p>
En xeral, a función a utilizar é <b>solve</b>. Necesitará dous argumentos: o primeiro será unha lista de ecuacións separadas por comas, e o segundo a lista de incógnitas.
</p>

<p>
Unha sinxela ecuación de primeiro grao.
</p>

<pre>
solve([5 * (x + 1/2) = 1 + x /3], [x]) ;
</pre>

<p>
A mesma ecuación pero cunha constante.
</p>

<pre>
solve([5 * (x + 1/2) = k + x /3], [x]) ;
</pre>

<p>
Unha ecuación polinómica de segundo grao. Recorda que a raíz cuadrada se representa en Maxima por <b>sqrt</b> e a unidade imaxinaria por <b>%i</b>.
</p>

<pre>
solve([2*x^2 - 3*x + 5 = 0], [x]) ;
</pre>

<p>
Un sistema de ecuacións. Vemos neste exemplo que podemos facer uso de varias liñas para escribir unha sentencia. Tamén pedimos o resultado en formato decimal.
</p>

<pre>
sol : solve([5*x + y/8 = 4, x^2 = y],
            [x,y]) ;

float(sol);
</pre>

<p>Cando os métodos alxébricos non se poidan utilizar, podemos facer uso das rutinas numéricas. A libraría <b>mnewton</b> pode resolver ecuacións e sistemas de ecuacións polo método de Newton. Chamamos á función <b>mnewton</b> con tres argumentos: a lista de ecuacións, a lista de incógnitas e as coordenadas do punto inicial.</p>

<pre>
load("mnewton") $

/* equation with sigle unknown */
mnewton([2*a^a = 5],[a],[1]);

/* multiple unknowns */
mnewton([2*3^u-v/u-5 = 0, u+2^v = 4], [u, v], [2, 2]);
</pre>









<h3 id="vectores">Vectores</h3>

<p>Os vectores represéntanse como listas pechadas entre corchetes. Podemos realizar con eles algunhas operacións habituais.</p>

<pre>
v1: [1, 2, 3] $
v2: [a, b, c] $

/* suma e resta */
v1 + v2;
v1 - v2;

/* produto por un numero */
k * v1;

/* produto escalar */
v1 . v2;
</pre>

<p>O produto vectorial está definido na libraría <b>vector3d</b>.</p>

<pre>
load(vector3d) $
cross([a, b, c] , [x, y, z]);
</pre>

<p>Aquí hai un exemplo de como se define unha nova función en Maxima. Queremos escribir unha función que calcule o módulo dun vector; obsérvese que as funcións defínense por medio do operador <b>:=</b>. Vale, non te preocupes se non entendes a parte interna da función.</p>

<pre>
modulus(v):= sqrt(apply("+", v^2)) $
modulus([a, 5, c]);
</pre>









<h3 id="matrices">Matrices</h3>

<p>
As matrices pódense introducir de varios xeitos. O máis frecuente é facer uso da función <b>matrix</b> declarando as filas. Neste exemplo introdúcense dúas matrices para despois sumalas e restalas.
</p>

<pre>
a : matrix([1, 2, 3], [4, 5, 6]) ;
b : matrix([7, 1/9, 2], [z, x+y, -5]) ;

a + b ;
a - b ;
</pre>

<p>
O produto matricial indícase co punto (<b>.</b>), non co asterisco.
</p>

<pre>
a : matrix([1, 2, 3], [4, 5, 6]) ;
b : matrix([7, 1/9], [z, -5], [1, 0]) ;

a . b ;
</pre>

<p>
Outra particularidade é que o cálculo da potencia dunha matriz indícase mediante o doble acento circunflexo.
</p>

<pre>
a : matrix([1, 2, 3], [4, 5, 6], [7, 8, 9]) ;
a^^3 ;
</pre>

<p>
Outras operacións con matrices.
</p>

<pre>
a : matrix([1, 4, 3], [7, 5, 6], [3, 8, 9]) ;

/* Matriz inversa */
invert(a) ;

/* Matriz trasposta */
transpose(a) ;

/* Determinante */
determinant(a) ;
</pre>

<p>Hai matrices que se definen de xeito especial, como a identidade e a matriz nula.</p>

<pre>
ident(4);
zeromatrix(4,2);
</pre>

<p>Dada unha matriz, calculamos o seu polinomio característico, os seus valores e vectores propios.</p>

<pre>
A: matrix([1,3], [5,7]);

/* o segundo argumento e o nome da variable */
charpoly(A, x);

/* os valores propios e as suas multiplicidades */
eigenvalues(A);

/* os valores propios e os seus vectores correspondentes */
eigenvectors(A);
</pre>











<hr>
<h2 id="calculo">Cálculo</h2>


<h3 id="limites">Límites</h3>

<p>
A función <b>limit</b> á a que nos permite calcular límites.
</p>

<p>
O máis infinito represéntase por <b>inf</b> e o menos infinito por <b>minf</b>.
</p>

<pre>
f: (x-1) / (2*x + 3) ;

/* x achegase a 1 */
limit(f, x, 1);

/* x achegase a mais infinito */
limit(f, x, inf);

/* x achegase a menos infinito */
limit(f, x, minf);
</pre>

<p>
Podemos achegarnos ó límite pola dereita o pola esquerda.
</p>

<pre>
g: 1 / (x-1);
limit(g, x, 1);

/* achegamonos a 1 pola dereita */
limit(g, x, 1, plus);

/* achegamonos a 1 pola esquerda */
limit(g, x, 1, minus);
</pre>








<h3 id="derivadas">Derivadas</h3>

<p>
Temos que chamar á función <b>diff</b>.
</p>

<pre>
fun: sin(x) * x^4 ;
diff(f, x);
</pre>

<p>Calculando derivadas de orde maior ca un.</p>

<pre>
/* orden tres */
diff(log(x)*x^x, x, 3);
</pre>

<p>Se queremos calcular derivadas implícitas, temos que dicirlle a Maxima que variables dependen da variable independente.</p>

<pre>
/* y e unha constante */
i: x^4 - x*y = cos(y^2+x);
diff(i, x);

/* agora, y depende de x */
depends(y,x) $
diff(i, x);
</pre>











<h3 id="integrais">Integrais</h3>

<p>
Chamamos á función <b>integrate</b> tanto para as integrais indefinidas como definidas.
</p>

<pre>
/* integral indefinida */
integrate(sin (2 + 3 * x), x) ;

/* integral definida */
integrate( x * exp(x), x, 1, 2) ;
</pre>

<p>Cando os métodos simbólicos non se poidan aplicar, podemos facer uso dalgunhas rutinas numéricas. Unha delas é <b>quad_qag</b>; pasarémoslle cinco argumentos, o integrando, a variable independente, os dous límites de integración e un enteiro entre 1 e 6, que é un parámetro do procedemento (3 adoita ser unha boa elección). O que se obtén é unha lista de números; o primero é o valor da integral definida e o segundo unha estimación do erro cometido.</p>

<pre>
quad_qag(exp(sin(x)),x,2,7,3);
</pre>











<h3 id="ecdiferenciais">Ecuacións diferenciais</h3>

<p>Para traballar con ecuacións diferenciais necesitamos dicirlle a Maxima que variable depende da variable independiente. Teremos que facer uso da función <b>ode2</b> para resolver ecuacións diferenciais ordinarias. </p>

<pre>
depends(y, x) $

/* unha ecuacion con variables separadas */
e: (x-1)*y^3+(y-1)*x^3*diff(y,x)=0;
r: ode2(e,y,x);

/* aplicamos condicions iniciais */
ic1(r,x=2,y=-3);
</pre>

<p>Resolvemos unha ecuación diferencial de Bernoulli.</p>

<pre>
depends(y, x) $
r: ode2(diff(y,x)-y+sqrt(y),y,x);

/* despexamos a variable dependente con solve */
solve(r, y);
</pre>

<p>Xunto coa función <b>ode2</b>, a libraría <b>contrib_ode</b> engade máis funcionalidades para resolver ecuacións diferenciais; véxase a documentación dispoñible.</p>

<p>Resolvendo unha ecuación diferencial de orde dous, trátase da ecuación do <i>movemento harmónico simple</i>.</p>

<pre>
depends(x, t) $

assume(k>0) $
e: diff(x,t,2) + k^2 * x = 0;
r: ode2(e, x, t);

/* aplicamos condicions iniciais */
ic2(r, t=0, x=1, diff(x,t)=1/2);

/* ou aplicamos condicions de contorna */
bc2(r, t=0, x=1, x=3, t=-1);

/* debuxamola! */
draw2d(explicit(rhs(s), t, 0, 10))$
</pre>

<p>Coa función <b>desolve</b> podemos resolver sistemas de ecuacións diferenciais, pero neste caso debemos indicar explícitamente as dependencias das funcións.</p>

<pre>
desolve(
    [diff(f(x),x)=3*f(x)-2*g(x),
     diff(g(x),x)=2*f(x)-2*g(x)],
    [f(x),g(x)]);
</pre>

<p>Se queremos aplicar condicións iniciais, temos que declaralas con <b>atvalue</b> antes de chamar a <b>desolve</b>.</p>

<pre>
atvalue(f(x),x=0,-1)$
atvalue(g(x),x=0,3)$
atvalue(h(x),x=0,1)$

desolve(
  [diff(f(x),x)=f(x)+g(x)+3*h(x),
   diff(g(x),x)=g(x)-2*h(x),
   diff(h(x),x)=f(x)+h(x)],
  [f(x),g(x),h(x)]);
</pre>

<p>Cando os métodos simbólicos non estean permitidos, podemos usar o método de Runge-Kutta (<b>rk</b>). Aquí tamén debuxamos a función resultante.</p>

<pre>
/* resolvemos dy/dt = 2 y^2-exp(-3 t) */
sol: rk(2*y^2-exp(-3*t), y, 0, [t, 0, 10, 0.2]) $

draw2d(
  points_joined = true,
  points(sol))$
</pre>






















<hr>
<h2 id="graficos">Gráficos</h2>

<p>
A mellor referencia para aprender a facer gráficos con Maxima é o documento <a href="http://riotorto.users.sf.net/gpdraw">A Maxima-Gnuplot interface</a>, que contén multitude de exemplos que se poden copiar e pegar no formulario. O manual de Maxima tamén ten unha sección adicada ós gráficos.
</p>

<p>
En Yamwi, a función para debuxar gráficos no plano é <b>draw2d</b>. Yamwi non executa a función gráfica <b>plot2d</b>, pero <b>wxdraw2d</b> tamén se acepta.
</p>

<p>
En primeiro lugar imos representar unha función explícita de cor vermella sobre o plano.
</p>

<pre>
draw2d (
  color = red,
  explicit(x^3-2*x^2+x-1, x, -3, 3) ) ;
</pre>

<p>
Imos engadirlle unha cuadrícula que faga máis doada a interpretación do gráfico. Ademáis, incorporamos á escena unha función paramétrica de trazo vermello algo máis groso.
</p>

<pre>
draw2d (
  explicit(x^3-2*x^2+x-1, x, -3, 3),
  grid = true,
  color = red,
  line_width = 4,
  parametric(sin(t), t^2, t, -2*%pi, 2*%pi) ) ;
</pre>

<p>
Tamén podemos facer gráficos en 3D. Neste caso a función a utilizar é <b>draw3d</b>.
</p>

<pre>
draw3d(
  surface_hide = true,
  explicit(20*exp(-x^2-y^2)-10,x,-3,3,y,-3,3));
</pre>

<p>
Por último, un exemplo de animación.
</p>

<pre>
draw(terminal   = animated_gif,
     delay      = 40,
     dimensions = [300,300],
     makelist(gr2d(explicit(x^(k/10),x,0,1)), k, 1, 10) ) $
</pre>













<hr>
<h2 id="estatistica">Estatística</h2>

<p>
As funcións estatísticas están definidas nun ficheiro de nome <b>descriptive</b>, polo que hai que invocalo antes de facer uso delas.
</p>

<p>
Os gráficos estatísticos definidos no paquete <b>descriptive</b> débense escribir coa pimeira letra en maiúscula: <b>Scatterplot</b>, <b>Histogram</b>, <b>Barsplot</b>, <b>Piechart</b>, <b>Boxplot</b> e <b>Starplot</b>.
</p>

<p>
Neste exemplo, a partir dunha serie de datos calculamos algúns parámetros estatísticos e xeramos a partir deles un diagrama de sectores.
<p>

<pre>
load(descriptive) $
mostra :
  [4, 7, 6, 1, 5, 10, 3, 6, 6, 6, 9, 9, 5, 2,
   2, 7, 7, 4, 6, 7, 8, 4, 10, 10, 4] $

/* media */
mean(mostra) ;

/* mediana */
median(mostra) ;

/* desviacion tipica */
std(mostra) ;

/* diagrama de sectores */
Piechart(mostra) $
</pre>

<p>
No caso dunha mostra bivariante, os pares debemos introducilos como unha matriz de dúas columnas. A partir de aí podemos xerar varios resultados.
</p>

<pre>
load(descriptive) $
mostra:
  matrix(
    [125.1,140.7], [130.6,155.1], [135.1,160.3],
    [140.0,167.2], [145.4,169.8], [142.7,168.5])$

/* vector de medias */
mean(mostra) ;

/* matriz de covarianzas */
cov(mostra) ;

/* matriz de correlacions */
cor(mostra) ;

/* grafico de dispersion */
draw2d(
   point_type = circle,
   point_size = 3,
   color = navy,
   points(mostra)) $
</pre>









<hr>
<p class="pie">Mario Rodríguez Riotorto</p>
</body>
</html>
