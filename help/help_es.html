<!doctype html>
<html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <link rel="stylesheet" media="all" href="help.css">
  <title>Sistema de ayuda de Yamwi en línea</title>
</head>

<body>


<h1>Sistema de ayuda de Yamwi en línea</h1>



<h2>Introducción</h2>

<p>
Esta página <i>web</i> permite hacer todo tipo de cálculos matemáticos y gráficos en línea.
</p>

<p>
Para hacer un cálculo cualquiera tan solo es necesario escribir en el cuadro el código correspondiente y a continuación pulsar en el botón que está debajo.
</p>

<p>
Los ejemplos que se incluyen en esta página se pueden copiar y pegar (CTRL-C y CTRL-V) en el área de edición antes de pulsar en el botón. El usuario puede hacer los cambios que quiera en esta área.
</p>

<p>
La ayuda de esta página es muy precaria y básica. Para profundizar más:
</p>

<ul>
<li>Referencia oficial: <a href="http://maxima.sourceforge.net/docs/manual/es/maxima.html" target="_blank">Manual de Maxima</a>.</li>
<li>Tutorial: <a href="http://www.telefonica.net/web2/biomates/maxima/max.pdf">Primeros pasos en Maxima</a>.</li>
<li>Desde la página oficial: <a href="http://maxima.sourceforge.net/es/documentation.html" target="_blank">Más tutoriales</a>. (Varias lenguas.)</li>
</ul>

<p>
La información que vamos a obtener tiene aspecto de conversación. Nuestras peticiones llevan siempre la etiqueta <b>%i</b> seguida de un número (<b>i</b> de <i>input</i>) y los resultados llevan la etiqueta <b>%o</b> seguida del correspondiente número de orden (<b>o</b> de <i>output</i>).
</p>













<hr>
<h2>Contenido</h2>

<ul>
<li><a href="#numeros">Números</a>
  <ul>
  <li><a href="#enteiros">Enteros</a></li>
  <li><a href="#racionais">Racionales</a></li>
  <li><a href="#complexos">Complejos</a></li>
  </ul>
</li>
<li><a href="#alxebra">Álgebra</a>
  <ul>
  <li><a href="#polinomios">Polinomios</a></li>
  <li><a href="#ecuacions">Ecuaciones</a></li>
  <li><a href="#vectores">Vectores</a></li>
  <li><a href="#matrices">Matrices</a></li>
  </ul>
</li>
<li><a href="#calculo">Cálculo</a>
  <ul>
  <li><a href="#limites">Límites</a></li>
  <li><a href="#derivadas">Derivadas</a></li>
  <li><a href="#integrais">Integrales</a></li>
  <li><a href="#ecdiferenciais">Ecuaciones diferenciales</a></li>
  </ul>
</li>
<li><a href="#graficos">Gráficos</a>
  <ul>
  <li><a href="#graficos2d">Gráficos 2D</a></li>
  <li><a href="#graficos3d">Gráficos 3D</a></li>
  </ul>
</li>
<li><a href="#estatistica">Estadística</a></li>
</ul>












<hr>
<h2 id="numeros">Números</h2>

<h3 id="enteiros"><br>Enteros</h3>

<p>Se pueden utilizar enteros tan grandes como sea necesario. Aquí calculamos el factorial de 100,</p>

<pre>
100! ;
</pre>

<p>Como en cualquier otro lenguaje de programación, podemos sumar (<b>+</b>), restar (<b>-</b>), multiplicar (<b>*</b>), dividir (<b>/</b>), calcular potencias (<b>^</b>) y raíces cuadradas (<b>sqrt</b>).</p>

<pre>
3^4 * (5-91+(-24)) + 75 / sqrt(25) ;
</pre>

<p>Veamos la lista de los divisores de un entero dado y su factorización en números primos,</p>

<pre>
/* primero guardamos el numero en la variable a */
a: 169996284 $
divisors(a) ;
factor(a) ;
</pre>

<p>Preguntamos a Maxima si 1502933 es un número primo.</p>

<pre>
primep(1502933);
</pre>

<p>Utilizamos <b>gcd</b> para calcular el <i>máximo común divisor</i> de dos números y <b>lcm</b> para el <i>mínimo común múltiplo</i> de un conjunto arbitrario de enteros, pero teniendo en cuenta que para usar <b>lcm</b> debemos cargar primero la librería <b>functs</b>.</p>

<pre>
gcd(16479936, 43375500000); 

load("functs")$
lcm(16479936, 43375500000, 111375);
</pre>

<p>La función <b>divide</b> devuelve una lista con dos elementos, el cociente y el resto (módulo) de una división entera.</p>

<pre>
divide(34, 5);
</pre>











<h3 id="racionais"><br>Racionales</h3>

<p>
Maxima siempre evita trabajar con cantidades aproximadas. Con el siguiente código operamos con racionales. Cada instrucción debe terminar con un punto y coma (<b>;</b>).
</p>

<pre>
1 + 5 * (5 - 7/9)^4 ;
</pre>

<p>
Si queremos la aproximación decimal de un resultado podemos proceder como sigue: primero guardamos (con dos puntos <b>:</b>) en una variable (en este caso <b>x</b>) el valor de la expresión exacta y después ejecutamos la función <b>float</b> para que la transforme a decimal.
</p>

<pre>
x : 1 + 5 * (5 - 7/9)^4 ;
float(x);
</pre>

<p>
El mismo resultado se puede conseguir con una sola instrucción.
</p>

<pre>
float (1 + 5 * (5 - 7/9)^4) ;
</pre>

<p>
Otro ejemplo en el que se ve el uso de variables. Lo que se escribe entre los símbolos <b>/*</b> y <b>*/</b> son comentarios para los humanos, siendo ignorados por la máquina, de manera que este ejemplo es autoexplicativo.
</p>

<pre>
/* Guardamos un valor en la variable 'a' */
a : 8 / 24;

/* Guardamos otro valor en la variable 'b' */
b: 1/5 ;

/* El cuadrado de la suma de 'a' e 'b' */
(a + b)^2;
</pre>

<p>
La función <b>float</b> devuelve un número limitado de decimales. Veamos cómo pedir el número &pi; con cinco mil decimales. Para eso debemos indicarle a la variable global <b>fpprec</b> la precisión deseada y después hacer una llamada a la función <b>bfloat</b>. Conviene recordar que &pi; se representa en Maxima por <b>%pi</b>. También calculamos la raíz cuadrada de 2 con 5000 cifras decimales.
</p>

<pre>
fpprec : 5000;
bfloat(%pi);

/* Tambien queremos la raiz cuadrada de dos */
bfloat( sqrt(2) );
</pre>











<h3 id="complexos"><br>Complejos</h3>

<p>La unidad imaginaria se representa por <b>%i</b>. Con este símbolo, podemos escribir cualquier número complejo y realizar algunas operaciones con ellos.</p>

<pre>
z1: 3 + 5*%i;
z2: 2/3 - %i;

z1 + z2;
z1 - z2;
</pre>

<p>A veces, Maxima devuelve expresiones complejas con paréntesis. Si queremos simplificar estas expresiones, podemos llamar a la función <b>expand</b>.</p>

<pre>
z1: 3 + 5*%i $
z2: 2/3 - %i $

3*z1 - 7*z2;
expand(3*z1 - 7*z2);

z1 * z2;
expand(z1 * z2);
</pre>

<p>Podemos transformar números complejos en forma binomial a su forma polar y viceversa.</p>

<pre>
z: 3 + 5*%i ;
p: polarform(z);
b: rectform(p);
</pre>

<p>Dividamos dos números complejos y obtengamos el resultado en forma binomial,</p>

<pre>
d: (3 + 5*%i) / (7/8 - 1/4*%i) ;
rectform(d);
</pre>

<p>Dado un número complejo, podemos obtener sus partes real e imaginaria, así como su módulo y ángulo.</p>

<pre>
z: 7/8 - 1/4*%i;
realpart(z);
imagpart(z);
cabs(z);
carg(z);
</pre>










<hr>
<h2 id="alxebra">Álgebra</h2>



<h3 id="polinomios"><br>Polinomios</h3>

<p>
De la misma forma que podemos operar con números, lo podemos hacer con variables. Fíjate cómo se reducen las expresiones algebraicas.
</p>

<pre>
1 + x + 5 * y - 2/3 * x + y + 2 ;

(5*x^2 * u * r) / (u^2 * t) ;
</pre>

<p>
Expandimos productos.
</p>

<pre>
expand( (x+1)^2 * (x+5) * (x-a) ) ;
</pre>


<p>
Factorizamos polinomios.
</p>

<pre>
factor(u^6 - 14*u^5 - 23*u^4 + 808*u^3 - 320*u^2 - 12800*u) ;
</pre>

<p>
Si queremos calcular el valor numérico de una expresión algebraica, haremos uso de la función <b>subst</b> tal como se indica a continuación, donde guardamos en la variable <b>f</b> la fórmula para la fuerza de atracción gravitatoria y la calculamos para diferentes masa y distancias. El uso de los corchetes (<b>[</b> y <b>]</b>) en Maxima es muy común, ya que con ellos podemos construir listas y cualesquiera otras estructuras de datos.
</p>

<pre>
f : 6.67 * 10^-11 * m1 * m2 / r^2 ;

subst([m1 = 4, m2 = 5, r = 7], f) ;
subst([m1 = mass, m2 = mass], f) ;
</pre>











<h3 id="ecuacions"><br>Ecuaciones</h3>

<p>
En general, la función a utilizar es <b>solve</b>. Necesitamos dos argumentos: el primero será una lista de ecuaciones separadas por comas y el segundo otra lista con las incógnitas.
</p>



<p>
Una sencilla ecuación de primer grado.
</p>

<pre>
solve([5 * (x + 1/2) = 1 + x /3], [x]) ;
</pre>

<p>
La misma ecuación pero con una constante.
</p>

<pre>
solve([5 * (x + 1/2) = k + x /3], [x]) ;
</pre>

<p>
Una ecuación polinómica de segundo grado. Recuerda que la raíz cuadrada se representa en Maxima por <b>sqrt</b> y la unidad imaginaria por <b>%i</b>.
</p>

<pre>
solve([2*x^2 - 3*x + 5 = 0], [x]) ;
</pre>

<p>
Un sistema de ecuaciones. Vemos en este ejemplo que podemos hacer uso de varias líneas para escribir una sentencia. También pedimos el resultado en formato decimal.
</p>

<pre>
sol : solve([5*x + y/8 = 4, x^2 = y],
            [x,y]) ;

float(sol);
</pre>

<p>Cuando los métodos algebraicos no se puedan utilizar, podemos hacer uso de las rutinas numéricas. La librería <b>mnewton</b> puede resolver ecuaciones y sistemas de ecuaciones por el método de Newton. Llamamos a la función <b>mnewton</b> con tres argumentos: la lista de ecuaciones, la lista de incógnitas y las coordenadas del punto inicial.</p>

<pre>
load("mnewton") $

/* equation with sigle unknown */
mnewton([2*a^a = 5],[a],[1]);

/* multiple unknowns */
mnewton([2*3^u-v/u-5 = 0, u+2^v = 4], [u, v], [2, 2]);
</pre>











<h3 id="vectores"><br>Vectores</h3>

<p>Los vectores se representan como listas encerradas entre corchetes. Podemos realizar con ellos algunas operaciones habituales.</p>

<pre>
v1: [1, 2, 3] $
v2: [a, b, c] $

/* suma y resta */
v1 + v2;
v1 - v2;

/* producto por un numero */
k * v1;

/* producto escalar */
v1 . v2;
</pre>

<p>El producto vectorial está definido en la librería <b>vector3d</b>.</p>

<pre>
load(vector3d) $
cross([a, b, c] , [x, y, z]);
</pre>

<p>Aquí hay un ejemplo de cómo se define una nueva función en Maxima. Queremos escribir una función que calcule el módulo de un vector; obsérvese que las funciones se definen por medio del operador <b>:=</b>. Vale, no te preocupes si no entiendes la parte interna de la función.</p>

<pre>
modulus(v):= sqrt(apply("+", v^2)) $
modulus([a, 5, c]);
</pre>











<h3 id="matrices"><br>Matrices</h3>

<p>
Las matrices se pueden introducir de varias maneras. La más frecuente es hacer uso de la función <b>matrix</b> declarando las filas. En este ejemplo se introducen dos matrices para después sumarlas y restarlas.
</p>

<pre>
a : matrix([1, 2, 3], [4, 5, 6]) ;
b : matrix([7, 1/9, 2], [z, x+y, -5]) ;

a + b ;
a - b ;
</pre>

<p>
El producto matricial se indica con el punto (<b>.</b>), no con el asterisco.
</p>

<pre>
a : matrix([1, 2, 3], [4, 5, 6]) ;
b : matrix([7, 1/9], [z, -5], [1, 0]) ;

a . b ;
</pre>

<p>
Otra particularidad es que el cálculo de la potencia de una matriz se indica mediante el doble acento circunflejo.
</p>

<pre>
a : matrix([1, 2, 3], [4, 5, 6], [7, 8, 9]) ;
a^^3 ;
</pre>

<p>
Otras operaciones con matrices.
</p>

<pre>
a : matrix([1, 4, 3], [7, 5, 6], [3, 8, 9]) ;

/* Matriz inversa */
invert(a) ;

/* Matriz transpuesta */
transpose(a) ;

/* Determinante */
determinant(a) ;
</pre>

<p>Hay matrices que se definen de forma especial, como la identidad y la matriz nula.</p>

<pre>
ident(4);
zeromatrix(4,2);
</pre>

<p>Dada una matriz, calculamos su polinomio característico, sus valores y vectores propios.</p>

<pre>
A: matrix([1,3], [5,7]);

/* el segundo argumento es el nombre de la variable */
charpoly(A, x);

/* los valores propios y sus multiplicidades */
eigenvalues(A);

/* los valores propios y sus vectores correspondientes */
eigenvectors(A);
</pre>













<hr>
<h2 id="calculo">Cálculo</h2>


<h3 id="limites"><br>Límites</h3>

<p>
La función <b>limit</b> es la que nos permite calcular límites.
</p>

<p>
El más infinito  se representa por <b>inf</b> y el menos infinito por <b>minf</b>.
</p>

<pre>
f: (x-1) / (2*x + 3) ;

/* x se aproxima a 1 */
limit(f, x, 1);

/* x se aproxima a mas infinito */
limit(f, x, inf);

/* x se aproxima a menos infinito */
limit(f, x, minf);
</pre>

<p>
Podemos aproximar el límite por la derecha o por la izquierda.
</p>

<pre>
g: 1 / (x-1);
limit(g, x, 1);

/* nos aproximamos a 1 por la derecha */
limit(g, x, 1, plus);

/* nos aproximamos a 1 por la izquierda */
limit(g, x, 1, minus);
</pre>








<h3 id="derivadas"><br>Derivadas</h3>

<p>
Tenemos que llamar a la función <b>diff</b>.
</p>

<pre>
fun: sin(x) * x^4 ;
diff(f, x);
</pre>

<p>Calculando derivadas de orden mayor que uno.</p>

<pre>
/* orden tres */
diff(log(x)*x^x, x, 3);
</pre>

<p>Si queremos calcular derivadas implícitas, tenemos que decirle a Maxima qué variables dependen de la variable independiente.</p>

<pre>
/* y es una constante */
i: x^4 - x*y = cos(y^2+x);
diff(i, x);

/* ahora, y depende de x */
depends(y,x) $
diff(i, x);
</pre>








<h3 id="integrais"><br>Integrales</h3>

<p>
Llamamos a la función <b>integrate</b> tanto para las integrales indefinidas como definidas.
</p>

<pre>
/* integral indefinida */
integrate(sin (2 + 3 * x), x) ;

/* integral definida */
integrate( x * exp(x), x, 1, 2) ;
</pre>

<p>Cuando los métodos simbólicos no se pueden aplicar, podemos hacer uso de algunas rutinas numéricas. Una de ellas es <b>quad_qag</b>; necesita cinco argumentos, el integrando, la variable independiente, los dos límites de integración y un entero entre 1 y 6, que es un parámetro del procedimiento (3 suele ser una buena elección). Lo que se obtiene es una lista de números; el primero es el valor de la integral definida y el segundo una estimación del error cometido.</p>

<pre>
quad_qag(exp(sin(x)),x,2,7,3);
</pre>








<h3 id="ecdiferenciais"><br>Ecuaciones diferenciales</h3>

<p>Para trabajar con ecuaciones diferenciales necesitamos decirle a Maxima qué variable depende de la variable independiente. Tendremos que hacer uso de la función <b>ode2</b> para resolver ecuaciones diferenciales ordinarias. </p>

<pre>
depends(y, x) $

/* una ecuacion con variables separadas */
e: (x-1)*y^3+(y-1)*x^3*diff(y,x)=0;
r: ode2(e,y,x);

/* aplicamos condiciones iniciales */
ic1(r,x=2,y=-3);
</pre>

<p>Resolvemos una ecuación diferencial de Bernoulli.</p>

<pre>
depends(y, x) $
r: ode2(diff(y,x)-y+sqrt(y),y,x);

/* despejamos la variable dependiente con solve */
solve(r, y);
</pre>

<p>Junto con la función <b>ode2</b>, la librería <b>contrib_ode</b> añade más funcionalidades para resolver ecuaciones diferenciales; véase la documentación disponible.</p>

<p>Resolviendo una ecuación diferencial de orden dos, se trata de la ecuación del <i>movimiento armónico simple</i>.</p>

<pre>
depends(x, t) $

assume(k>0) $
e: diff(x,t,2) + k^2 * x = 0;
r: ode2(e, x, t);

/* aplicamos condiciones iniciales */
ic2(r, t=0, x=1, diff(x,t)=1/2);

/* o aplicamos condiciones de contorno */
bc2(r, t=0, x=1, x=3, t=-1);

/* la dibujamos! */
draw2d(explicit(rhs(s), t, 0, 10))$
</pre>

<p>Con la función <b>desolve</b> podemos resolver sistemas de ecuaciones diferenciales, pero en este caso debemos indicar explícitamente las dependencias de las funciones.</p>

<pre>
desolve(
    [diff(f(x),x)=3*f(x)-2*g(x),
     diff(g(x),x)=2*f(x)-2*g(x)],
    [f(x),g(x)]);
</pre>

<p>Si queremos aplicar condiciones iniciales, tenemos que declararlas con <b>atvalue</b> antes de llamar a <b>desolve</b>.</p>

<pre>
atvalue(f(x),x=0,-1)$
atvalue(g(x),x=0,3)$
atvalue(h(x),x=0,1)$

desolve(
  [diff(f(x),x)=f(x)+g(x)+3*h(x),
   diff(g(x),x)=g(x)-2*h(x),
   diff(h(x),x)=f(x)+h(x)],
  [f(x),g(x),h(x)]);
</pre>

<p>Cuando los métodos simbólicos no están permitidos, podemos usar el método de Runge-Kutta (<b>rk</b>). Aquí también dibujamos la función resultante.</p>

<pre>
/* resolvemos dy/dt = 2 y^2-exp(-3 t) */
sol: rk(2*y^2-exp(-3*t), y, 0, [t, 0, 10, 0.2]) $

draw2d(
  points_joined = true,
  points(sol))$
</pre>









<hr>
<h2 id="graficos">Gráficos</h2>

<p>
La mejor referencia para aprender a hacer gráficos con Maxima es el documento <a href="http://riotorto.users.sf.net/gpdraw">A Maxima-Gnuplot interface</a>, que contiene multitud de ejemplos que se pueden copiar y pegar en el formulario. El manual de Maxima también tiene una sección dedicada a los gráficos.
</p>










<h3 id="graficos2d"><br>Gráficos 2D</h3>

<p>
Los gráficos en 2D pueden hacerse con la función <b>draw2d</b>.
</p>

<p>
Las opciones se escriben en el formato <b>opción = valor</b> y los objetos gráficos de la forma  <b>objeto(arg<sub>1</sub>, arg<sub>2</sub>, ...)</b>. 
</p>

<p>Aquí se representa una función explícita en rojo. Las funciones explícitas necesitan una expresión, el nombre de la variable independiente y los extremos del dominio a representar.</p>

<pre>
draw2d (
  color = red,
  explicit(x^3-2*x^2+x-1, x, -3, 3) ) $
</pre>

<p>
Las opciones se leen secuencialmente y afectan a los objetos gráficos que se declaren a continuación. A continuación una función explícita junto con otra paramétrica. Se añade una rejilla en el fondo.
</p>

<pre>
draw2d (
  explicit(x^3-2*x^2+x-1, x, -3, 3),
  grid       = true,
  color      = red,
  line_width = 4,
  parametric(sin(t), t^2, t, -2*%pi, 2*%pi) ) $
</pre>

<p>Podemos dibujar puntos aislados y líneas poligonales. Las coordenadas de los puntos se pueden pasar al objeto <b>points</b> como una lista de pares, escribiendo la lista de abscisas seguida de la lista de ordenadas o dando solamente la lista de ordenadas. También se ve que los colores se pueden declarar en forma hexadecimal y que el estilo de los puntos, excepto el color, afecta a los últimos dos objetos.</p>

<pre>
draw2d (
  /* estilo por defecto */
  points([[2,3], [7,4], [0,5], [5,2/3], [7,-1], [8,3], [-2,10]]),

  point_type    = circle,
  point_size    = 3,
  color         = brown,
  points_joined = true,
  points([3, 4, 6, 8], [-2, -5, 3, 1]),

  color = "#ff670d",
  points([2, 6, 2, 8, 9])  ) $
</pre>

<p>Una función implícita, una función definida en coordenadas polares y un polígono.</p>

<pre>
draw2d(
  /* opciones globales */
  title      = "Escribe tu titulo",
  xlabel     = "eje-x",
  ylabel     = "eje-y",
  grid       = true,
  dimensions = [500,500],

  /* funcion implicita */
  key = "Implicita",
  implicit(y^2=x^3-2*x+1, x, -4,4, y, -4,6),

  /* coordenadas polares */
  key   = "Polar",
  color = red,
  polar(10/theta,theta,1,3*%pi),

  /* poligono */
  key        = "Poligono",
  fill_color = sea_green,
  color      = aquamarine,
  line_width = 6,
  polygon([[1,1],[3,0],[4,5],[0,3]]) ) $
</pre>











<h3 id="graficos3d"><br>Gráficos 3D</h3>

<p>
También podemos hacer gráficos en 3D. En este caso la función a utilizar es <b>draw3d</b>.
</p>

<pre>
draw3d(
  surface_hide = true,
  explicit(20*exp(-x^2-y^2)-10,x,-3,3,y,-3,3));
</pre>

<p>
Por último, un ejemplo de animación.
</p>

<pre>
draw(terminal   = animated_gif,
     delay      = 40,
     dimensions = [300,300],
     makelist(gr2d(explicit(x^(k/10),x,0,1)), k, 1, 10) ) $
</pre>













<hr>
<h2 id="estatistica">Estadística</h2>

<p>
Las funciones estadísticas están definidas en un fichero de nombre <b>descriptive</b>, por lo que hay que cargarlo antes de hacer uso de ellas.
</p>

<p>
Los gráficos estadísticos definidos en el paquete <b>descriptive</b> se deben escribir con la pimera letra en mayúscula: <b>Scatterplot</b>, <b>Histogram</b>, <b>Barsplot</b>, <b>Piechart</b>, <b>Boxplot</b> y <b>Starplot</b>.
</p>

<p>
En este ejemplo, a partir de una serie de datos calculamos algunos parámetros estadísticos y generamos a partir de ellos un diagrama de sectores.
<p>

<pre>
load(descriptive) $
mostra :
  [4, 7, 6, 1, 5, 10, 3, 6, 6, 6, 9, 9, 5, 2,
   2, 7, 7, 4, 6, 7, 8, 4, 10, 10, 4] $

/* media */
mean(mostra) ;

/* mediana */
median(mostra) ;

/* desviacion tipica */
std(mostra) ;

/* diagrama de sectores */
Piechart(mostra) $
</pre>

<p>
En caso de muestra bivariante, los pares debemos introducirlos como una matriz de dos columnas. A partir de ahí podemos generar varios resultados.
</p>

<pre>
load(descriptive) $
mostra:
  matrix(
    [125.1,140.7], [130.6,155.1], [135.1,160.3],
    [140.0,167.2], [145.4,169.8], [142.7,168.5])$

/* vector de medias */
mean(mostra) ;

/* matriz de covarianzas */
cov(mostra) ;

/* matriz de correlaciones */
cor(mostra) ;

/* grafico de dispersion */
draw2d(
   point_type = circle,
   point_size = 3,
   color = navy,
   points(mostra)) $
</pre>










<hr>
<p class="pie">Mario Rodríguez Riotorto</p>
</body>
</html>
